{"version":3,"sources":["resources/images/logo.png","service/validator/Validator.js","service/fileprocessor/CsvFileParser.js","service/fileprocessor/PrnFileParser.js","service/fileprocessor/FileParserFactory.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","validateCreditLimit","name","creditLimit","isNaN","logError","undefined","validatePhoneNumber","phoneNumber","matches","match","validateBirthday","birthday","format","date","parse","toString","field","value","error","console","log","fileAsBinaryString","onSuccess","csv","fromString","then","rawPersons","postProcess","errors","persons","forEach","person","validator","Name","push","toDateString","getFileType","HEADERS","lines","split","headerLine","columnIndexes","i","length","start","end","indexOf","j","substring","trim","amount","getFileParser","fileType","prnFileParser","csvFileParser","App","props","render","className","src","logo","alt","Typography","variant","renderUploadButton","renderPersonTable","renderDownloadHtmlButton","renderErrorMessages","accept","id","multiple","type","onChange","processFiles","htmlFor","Tooltip","title","Fab","component","color","aria-label","event","callbacks","processFile","target","files","index","file","substr","reader","FileReader","onload","e","result","fileParserFactory","parsingResult","storeParsingResultInMemory","readAsText","callback","personCache","state","rawPerson","has","updatePerson","set","setState","personToUpdate","get","newCreditLimit","found","storedCreditLimit","source","personCacheHasData","Zoom","in","Paper","Table","TableHead","TableRow","renderHeaders","renderTableBody","TablePagination","count","size","rowsPerPageOptions","rowsPerPage","pageSize","onChangeRowsPerPage","handleChangeRowsPerPage","page","currentPage","backIconButtonProps","nextIconButtonProps","onChangePage","changePage","map","headerName","TableCell","key","paginationOffset","TableBody","values","slice","personRow","renderPersonCells","header","renderPersonCell","renderCreditLimitCell","renderOriginCell","List","ListItem","onClick","downloadHtml","html","document","getElementById","outerHTML","link","createElement","download","blob","Blob","href","window","URL","createObjectURL","click","Snackbar","anchorOrigin","vertical","horizontal","open","autoHideDuration","ContentProps","message","join","action","IconButton","removeError","Map","Component","Boolean","location","hostname","ReactDOM","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.e52c856e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.bc6729bc.png\";","import date from 'date-and-time';\r\n\r\n/**\r\n * Does validation of person credit limit data.\r\n */\r\nclass Validator {\r\n\r\n\t/**\r\n\t * Validates given credit limit and returns error if invalid.\r\n\t * \r\n\t * @param name \t\t\tperson name\r\n\t * @param creditLimit \tcredit limit to validate\r\n\t * @return error string if credit limit is invalid, undefined otherwise\r\n\t */\r\n\tvalidateCreditLimit = (name, creditLimit) => {\r\n\t\treturn isNaN(creditLimit) ? this.logError(name, 'credit limit', creditLimit) : undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Validates given phone number and returns error if invalid.\r\n\t * \r\n\t * @param name \t\t\tperson name\r\n\t * @param phoneNumber \tphone number to validate\r\n\t * @return error string if phone number is invalid, undefined otherwise\r\n\t */\r\n\tvalidatePhoneNumber = (name, phoneNumber) => {\r\n\r\n\t\tvar matches = phoneNumber.match(/^[+\\-0-9(). ]+$/);\r\n\t\treturn !matches || phoneNumber !== matches[0] ? this.logError(name, 'phone number', phoneNumber) : undefined;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Validates given birthday agains given format and returns error if invalid.\r\n\t * \r\n\t * @param name \t\t\tperson name\r\n\t * @param birthday \t\tbirthday to validate\r\n\t * @param format\t\tdate format to use for validation\r\n\t * @return error string if birthday is invalid, undefined otherwise\r\n\t */\r\n\tvalidateBirthday = (name, birthday, format) => {\r\n\t\tvar birthdayDate = date.parse(birthday, format);\r\n\t\treturn birthdayDate.toString() === 'Invalid Date' ? this.logError(name, 'birthday', birthday) : undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Logs and returns the error.\r\n\t * \r\n\t * @param name\t\tperson name\r\n\t * @param field \tfield name\r\n\t * @param value \tfield value\r\n\t * @return string representing the error\r\n\t */\r\n\tlogError = (name, field, value) => {\r\n\r\n\t\tlet error = name + ' has invalid ' + field + ' (' + value + ') and is skipped';\r\n\t\tconsole.log(error);\r\n\t\treturn error;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default new Validator();","import csv from 'csvtojson';\r\nimport date from 'date-and-time';\r\nimport validator from './../validator/Validator';\r\n\r\n/**\r\n * Responsible for parsing person credit limit data from a csv file.\r\n */\r\nclass CsvFileParser {\r\n\r\n\t/**\r\n\t * Parses person credit limit data from a given csv file content and calls given callback when done.\r\n\t * \r\n\t * @param fileAsBinaryString\tcsv file content\r\n\t * @param onSuccess\t\t\t\tsuccess callback\r\n\t */\r\n\tparse = (fileAsBinaryString, onSuccess) => {\r\n\r\n\t\tcsv()\r\n\t\t.fromString(fileAsBinaryString)\r\n\t\t.then((rawPersons) => {\r\n\t\t\tonSuccess(this.postProcess(rawPersons));\t\t\t\t\t\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Does post processing and validation on the data parsed from csv file.\r\n\t * Validates credit limits, phone numbers and birthdays.\r\n\t *\r\n\t * @param rawPersons\tdata parsed from csv file\r\n\t * @return object that holds person data and errors related to persons that were ommited from the result \r\n\t */\r\n\tpostProcess = (rawPersons) => {\r\n\r\n\t\tvar errors = [];\r\n\t\tvar persons = [];\r\n\r\n\t\trawPersons.forEach(person => {\r\n\r\n\t\t\tlet error = validator.validateCreditLimit(person.Name, person['Credit Limit']);\r\n\t\t\tif (error) {\r\n\t\t\t\terrors.push(error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\terror = validator.validatePhoneNumber(person.Name, person['Phone']);\r\n\t\t\tif (error) {\r\n\t\t\t\terrors.push(error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\terror = validator.validateBirthday(person.Name, person['Birthday'], 'DD/MM/YYYY');\r\n\t\t\tif (error) {\r\n\t\t\t\terrors.push(error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar birthday = date.parse(person['Birthday'], 'DD/MM/YYYY');\r\n\t\t\tperson['Birthday'] = birthday.toDateString();\r\n\r\n\t\t\tperson['Credit Limit'] = {\r\n\t\t\t\t'amount': person['Credit Limit'],\r\n\t\t\t\t'source': 'csv'\r\n\t\t\t};\r\n\t\t\tpersons.push(person);\r\n\r\n\r\n\t\t});\r\n\r\n\t\treturn {\r\n\t\t\trawPersons: persons,\r\n\t\t\terrors: errors\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns file type for which this file parser is responsible.\r\n\t */\r\n\tgetFileType = () => {\r\n\t\treturn 'csv';\r\n\t}\r\n\r\n}\r\n\r\nexport default new CsvFileParser();","import date from 'date-and-time';\r\nimport validator from './../validator/Validator';\r\n\r\nconst HEADERS = [ 'Name', 'Address', 'Postcode', 'Phone', 'Credit Limit', 'Birthday' ];\r\n\r\n/**\r\n * Responsible for parsing person credit limit data from a prn file.\r\n */\r\nclass PrnFileParser {\r\n\r\n\t/**\r\n\t * Parses person credit limit data from a given prn file content and calls given callback when done.\r\n\t * \r\n\t * @param fileAsBinaryString\tprn file content\r\n\t * @param onSuccess\t\t\t\tsuccess callback\r\n\t */\r\n\tparse = (fileAsBinaryString, onSuccess) => {\r\n\r\n\t\tvar lines = fileAsBinaryString.split('\\n');\r\n\t\tvar headerLine = lines[0];\r\n\t\tvar columnIndexes = [];\r\n\t\tvar rawPersons = [];\r\n\r\n\t\tfor (var i = 0;i < HEADERS.length;i++) {\r\n\r\n\t\t\tcolumnIndexes.push({\r\n\t\t\t\tstart: i === 0 ? 0 : columnIndexes[i - 1].end,\r\n\t\t\t\tend: i === HEADERS.length - 1 ? headerLine.length : headerLine.indexOf(HEADERS[i + 1])\r\n\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tfor (i = 1;i < lines.length;i++) {\r\n\r\n\t\t\tif (!lines[i]) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tvar person = {};\r\n\r\n\t\t\tfor (var j = 0;j < HEADERS.length;j++) {\r\n\t\t\t\tvar value = lines[i].substring(columnIndexes[j].start, columnIndexes[j].end).trim();\r\n\t\t\t\tperson[HEADERS[j]] = HEADERS[j] === 'Credit Limit' ? { 'amount': value, 'source': 'prn' } : value;\r\n\t\t\t}\r\n\r\n\t\t\trawPersons.push(person);\r\n\r\n\t\t}\r\n\r\n\t\tonSuccess(this.postProcess(rawPersons));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Does post processing and validation on the data parsed from prn file.\r\n\t * Validates credit limits, phone numbers and birthdays.\r\n\t *\r\n\t * @param rawPersons\tdata parsed from prn file\r\n\t * @return object that holds person data and errors related to persons that were ommited from the result \r\n\t */\r\n\tpostProcess = (rawPersons) => {\r\n\r\n\t\tvar errors = [];\r\n\t\tvar persons = [];\r\n\r\n\t\trawPersons.forEach(person => {\r\n\r\n\t\t\tlet error = validator.validateCreditLimit(person.Name, person['Credit Limit'].amount);\r\n\t\t\tif (error) {\r\n\t\t\t\terrors.push(error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\terror = validator.validatePhoneNumber(person.Name, person['Phone']);\r\n\t\t\tif (error) {\r\n\t\t\t\terrors.push(error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\terror = validator.validateBirthday(person.Name, person['Birthday'], 'YYYYMMDD');\r\n\t\t\tif (error) {\r\n\t\t\t\terrors.push(error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar birthday = date.parse(person['Birthday'], 'YYYYMMDD');\r\n\t\t\tperson['Birthday'] = birthday.toDateString();\r\n\r\n\t\t\tpersons.push(person);\r\n\t\t});\r\n\r\n\t\treturn {\r\n\t\t\trawPersons: persons,\r\n\t\t\terrors: errors\r\n\t\t};\r\n\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns file type for which this file parser is responsible.\r\n\t */\r\n\tgetFileType = () => {\r\n\t\treturn 'prn';\r\n\t}\r\n\r\n}\r\n\r\nexport default new PrnFileParser();","import csvFileParser from './CsvFileParser';\r\nimport prnFileParser from './PrnFileParser';\r\n\r\n/**\r\n * Responsible for providing appropriate file parser. \r\n */\r\nclass FileParserFactory {\r\n\r\n\t/**\r\n\t * Returns appropriate file parser for a given file type.\r\n\t * If none is matching CsvFileParser is returned.\r\n\t *\r\n\t * @param fileType that we need file parser for\r\n\t * @return file parser\r\n\t */\r\n\tgetFileParser = (fileType) => {\r\n\r\n\t\tswitch(fileType) {\r\n\t\t\tcase 'prn': return prnFileParser;\r\n\t\t\tdefault: return csvFileParser\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default new FileParserFactory();","import React, { Component } from 'react';\r\nimport logo from './resources/images/logo.png';\r\nimport './App.css';\r\n\r\nimport Fab from '@material-ui/core/Fab';\r\nimport List from '@material-ui/core/List';\r\nimport ListItem from '@material-ui/core/ListItem';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Snackbar from '@material-ui/core/Snackbar';\r\nimport Table from '@material-ui/core/Table';\r\nimport TableBody from '@material-ui/core/TableBody';\r\nimport TableCell from '@material-ui/core/TableCell';\r\nimport TableHead from '@material-ui/core/TableHead';\r\nimport TableRow from '@material-ui/core/TableRow';\r\nimport TablePagination from '@material-ui/core/TablePagination';\r\nimport Tooltip from '@material-ui/core/Tooltip';\r\nimport Zoom from '@material-ui/core/Zoom';\r\nimport CloudUploadIcon from '@material-ui/icons/CloudUpload';\r\nimport CloudDownloadIcon from '@material-ui/icons/GetApp';\r\nimport CloseIcon from '@material-ui/icons/Close';\r\n\r\nimport fileParserFactory from './service/fileprocessor/FileParserFactory';\r\n\r\nconst HEADERS = [ 'Name', 'Address', 'Postcode', 'Phone', 'Credit Limit', 'Origin', 'Birthday' ];\r\n\r\n/**\r\n * Responsible for receiving, displaying and HTML download of data about persons and their credit limits.\r\n */\r\nclass App extends Component {\r\n\r\n  constructor(props) {\r\n\r\n    super(props);\r\n    this.state = {\r\n      personCache: props.personCache || new Map(),\r\n      currentPage: 0,\r\n      pageSize: 5,\r\n      errors: undefined\r\n    };\r\n\r\n  }\r\n\r\n  /**\r\n   * Renders the page to display logo, upload and download buttons and credit limit table.\r\n   *\r\n   * @return div that holds whole page content\r\n   */\r\n  render = () => {\r\n\r\n    return (\r\n\r\n      <div className=\"App\">\r\n\r\n        <header className=\"App-header\">\r\n\r\n          <img src={ logo } className=\"App-logo\" alt=\"logo\" />\r\n          <Typography variant=\"caption\" className='Text'>Credit limit portal</Typography>\r\n          \r\n          { this.renderUploadButton() }\r\n          { this.renderPersonTable() }\r\n          { this.renderDownloadHtmlButton() }\r\n          { this.renderErrorMessages() }\r\n\r\n        </header>\r\n\r\n      </div>\r\n\r\n    );\r\n\r\n  }\r\n\r\n/**\r\n * Renders FAB button that is used to upload data file with credit limits to the system.\r\n *\r\n * @return div that holds upload button\r\n */\r\n  renderUploadButton = () => {\r\n    return (\r\n      <div className='UploadButton'>\r\n        <input className='UploadInput' accept=\".csv,.prn\" id=\"contained-button-file\" multiple type=\"file\" onChange={ this.processFiles }/>\r\n        <label htmlFor=\"contained-button-file\">\r\n          <Tooltip title='Upload credit limit data'>\r\n            <Fab component=\"span\" color=\"primary\" aria-label=\"Add\">\r\n              <CloudUploadIcon />\r\n            </Fab>\r\n          </Tooltip>\r\n        </label>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Takes all files from given event, processes them and passes given callbacks to be executed when processing is done.\r\n   *\r\n   * @param event     holds files to be processed\r\n   * @param callbacks array of functions to be called when each file is processed\r\n   */\r\n  processFiles = (event, callbacks) => {\r\n    this.processFile(event.target.files, 0, callbacks);\r\n  }\r\n\r\n  /**\r\n   * Processes given files in a recursive manner, by processing file with given index and then going to the next one.\r\n   * Callback for each file is called after its processing.\r\n   * \r\n   * @param files       files to be processed\r\n   * @param index       of the file that will be processed by the call\r\n   * @param callbacks   functions to be called after each file is processed\r\n   */\r\n  processFile = (files, index, callbacks) => {\r\n\r\n    if (index >= files.length) {\r\n      return;\r\n    }\r\n\r\n    var file = files[index];\r\n    var fileType = file.name.substr(file.name.length - 3);\r\n    var reader = new FileReader();\r\n\r\n    reader.onload = (e) => {\r\n\r\n      var fileAsBinaryString = e.target.result;\r\n\r\n      fileParserFactory.getFileParser(fileType).parse(fileAsBinaryString,\r\n        (parsingResult) => this.storeParsingResultInMemory(parsingResult, () => {\r\n\r\n          if (callbacks && callbacks[index]) {\r\n            callbacks[index]();\r\n          }\r\n          this.processFile(files, index + 1, callbacks);\r\n\r\n        })\r\n      );\r\n\r\n    };\r\n\r\n    reader.readAsText(file);\r\n\r\n  }\r\n\r\n  /**\r\n   * Stores result of data file parsing in the memory.\r\n   * NOTE: This method updates the state of the component.\r\n   *\r\n   * @param parsingResult holds persons credit limit data and errors if any\r\n   * @param callback      callback to be called once state is updated\r\n   */\r\n  storeParsingResultInMemory = (parsingResult, callback) => {\r\n\r\n    var personCache = this.state.personCache;\r\n\r\n    parsingResult.rawPersons.forEach(rawPerson => {\r\n\r\n      if (!personCache.has(rawPerson.Name)) {\r\n        rawPerson['Credit Limit'] = [ rawPerson['Credit Limit'] ];\r\n        personCache.set(rawPerson.Name, rawPerson);\r\n      } else {\r\n        this.updatePerson(rawPerson, personCache);\r\n      }\r\n\r\n    });\r\n\r\n    this.setState({\r\n      personCache: personCache,\r\n      errors: parsingResult.errors\r\n    }, callback);\r\n\r\n  }\r\n\r\n  /**\r\n   * Updates given person in the cache if it is there.\r\n   * Credit limit of the person is either overwritten if coming from the same source\r\n   * or it is added to existing ones if not. If all sources have same credit limit they will be merged to one.\r\n   *\r\n   * @param rawPerson   parsed person\r\n   * @param personCache map that holds all persons\r\n   */\r\n  updatePerson = (rawPerson, personCache) => {\r\n\r\n    var personToUpdate = personCache.get(rawPerson.Name);\r\n    if (!personToUpdate) {\r\n      return;\r\n    }\r\n    var newCreditLimit = rawPerson['Credit Limit'];\r\n    var found = false;\r\n\r\n    personToUpdate['Credit Limit'].forEach(storedCreditLimit => {\r\n\r\n      if (storedCreditLimit.source === newCreditLimit.source) {\r\n        storedCreditLimit.amount = newCreditLimit.amount;\r\n        found = true;\r\n      }\r\n\r\n    });\r\n\r\n    if (found) {\r\n      return;\r\n    }\r\n\r\n    if (personToUpdate['Credit Limit'].length === 1 && personToUpdate['Credit Limit'][0].amount === newCreditLimit.amount) {\r\n      personToUpdate['Credit Limit'][0].source = personToUpdate['Credit Limit'][0].source + ', ' + newCreditLimit.source;\r\n      return;\r\n    }\r\n\r\n    personToUpdate['Credit Limit'].push(newCreditLimit);\r\n\r\n  }\r\n\r\n  /**\r\n   * Renders table that display information about persons and their credit limits in a tabular manner.\r\n   *\r\n   * @return table that holds persons data\r\n   */\r\n  renderPersonTable = () => {\r\n\r\n    if (this.personCacheHasData()) {\r\n\r\n      return (\r\n        <Zoom in={ this.personCacheHasData() }>\r\n          <Paper>\r\n            <Table id='personsTable'>\r\n                  <TableHead>\r\n                    <TableRow>\r\n                      { this.renderHeaders() }\r\n                    </TableRow>\r\n                  </TableHead>\r\n                  { this.renderTableBody() }\r\n            </Table>\r\n                <TablePagination\r\n              component=\"div\"\r\n              count={ this.state.personCache.size}\r\n              rowsPerPageOptions= { [ 5, 10, 20, 200, 1000 ] }\r\n              rowsPerPage={ this.state.pageSize }\r\n              onChangeRowsPerPage={ this.handleChangeRowsPerPage }\r\n              page={ this.state.currentPage }\r\n              backIconButtonProps={{\r\n              'aria-label': 'Previous Page',\r\n              }}\r\n              nextIconButtonProps={{\r\n              'aria-label': 'Next Page',\r\n              }}\r\n              onChangePage={ this.changePage }\r\n                />\r\n          </Paper>\r\n        </Zoom>\r\n      );\r\n\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Handles change of page size.\r\n   * NOTE: This method is updating state.\r\n   */\r\n  handleChangeRowsPerPage = (event) => {\r\n    this.setState({\r\n      pageSize: event.target.value\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handles change of page.\r\n   * NOTE: This method is updating state.\r\n   */\r\n  changePage = (event, page) => {\r\n    this.setState({\r\n      currentPage: page\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Renders table headers.\r\n   *\r\n   * @return table headers\r\n   */\r\n  renderHeaders = () => {\r\n    return HEADERS.map(headerName => (\r\n      <TableCell className='TableHeader' key={ headerName }>\r\n        <Typography variant='h6'> { headerName } </Typography>\r\n      </TableCell>\r\n    ));\r\n  }\r\n\r\n  /**\r\n   * Renders body of the table.\r\n   *\r\n   * @return table body\r\n   */\r\n  renderTableBody = () => {\r\n    let paginationOffset = this.state.currentPage * this.state.pageSize;\r\n    return (\r\n      <TableBody>\r\n      {\r\n        [...this.state.personCache.values()].slice(paginationOffset, paginationOffset + this.state.pageSize).map((personRow, index) => {\r\n          return (\r\n            <TableRow key={ index }>\r\n              { this.renderPersonCells(personRow) }\r\n            </TableRow>\r\n          );\r\n        })\r\n      }\r\n      </TableBody>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Renders table cells for given person row.\r\n   *\r\n   * @param personRow holds data needed to render person row\r\n   * @return cells for a person row\r\n   */\r\n  renderPersonCells = (personRow) => {\r\n    return (\r\n      HEADERS.map((header, index) => {\r\n        return (\r\n          <TableCell key={ index }>\r\n            <Typography variant='caption'>\r\n              { this.renderPersonCell(personRow, header) }\r\n            </Typography>\r\n          </TableCell>\r\n        );\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Renders a single cell of a persons row.\r\n   *\r\n   * @param personRow holds data for persons row\r\n   * @param header    name of the cell header\r\n   * @return content of the table cell\r\n   */\r\n  renderPersonCell = (personRow, header) => {\r\n\r\n    switch (header) {\r\n\r\n      case 'Credit Limit': return this.renderCreditLimitCell(personRow);\r\n      case 'Origin': return this.renderOriginCell(personRow);\r\n      default: return personRow[header];\r\n\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Renders credit limit cell by displaying all its amounts in a list.\r\n   * \r\n   * @param personRow holds data about person\r\n   * @return list containing all credit limit amounts\r\n   */\r\n  renderCreditLimitCell = (personRow) => {\r\n    return (\r\n      <List component=\"nav\">\r\n        {\r\n          personRow['Credit Limit'].map((creditLimit, index) => {\r\n            return (\r\n              <ListItem key={ index }>\r\n                <Typography variant='caption'>\r\n                  { creditLimit.amount }\r\n                </Typography>\r\n              </ListItem>\r\n            );\r\n          })\r\n        }\r\n      </List>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Renders origin cell by displaying all credit limit sources in a list.\r\n   * \r\n   * @param personRow holds data about person\r\n   * @return list containing all credit limit origins\r\n   */\r\n  renderOriginCell = (personRow) => {\r\n    return (\r\n      <List component=\"nav\">\r\n        {\r\n          personRow['Credit Limit'].map((creditLimit, index) => {\r\n            return (\r\n              <ListItem key={ index }>\r\n                <Typography variant='caption'>\r\n                  { creditLimit.source }\r\n                </Typography>\r\n              </ListItem>\r\n            );\r\n          })\r\n        }\r\n      </List>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Renders button for HTML download.\r\n   *\r\n   * @return FAB button for download\r\n   */\r\n  renderDownloadHtmlButton = () => {\r\n\r\n    if (this.personCacheHasData()) {\r\n      return (\r\n        <div className='DownloadFab'>\r\n          <Tooltip title='Download credit data HTML'>\r\n            <Fab component=\"span\" color=\"primary\" aria-label=\"Download\" onClick={ this.downloadHtml }>\r\n              <CloudDownloadIcon />\r\n            </Fab>\r\n          </Tooltip>\r\n        </div>\r\n      );\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Handles clicks on the HTML donwload button.\r\n   * Fetches html of the table and initiates download of that html.\r\n   */\r\n  downloadHtml = () => {\r\n\r\n    var html = document.getElementById('personsTable').outerHTML;\r\n\r\n    var link = document.createElement('a');\r\n    link.download = 'credit_limit_overview.html';\r\n    var blob = new Blob([html], {type: 'text/html'});\r\n    link.href = window.URL.createObjectURL(blob);\r\n    link.click();\r\n\r\n  }\r\n\r\n  /**\r\n   * Checks if there are persons in the cache;\r\n   *\r\n   * @return true if cache is not empty, false otherwise\r\n   */\r\n  personCacheHasData = () => {\r\n    return this.state.personCache.size > 0;\r\n  }\r\n\r\n  /**\r\n   * Renders a snackbar that will display all errors present in the current state.\r\n   *\r\n   * @return snackbar that holds all errors\r\n   */\r\n  renderErrorMessages = () => {\r\n\r\n    return (\r\n      <Snackbar\r\n        className='ErrorSnackbar'\r\n        anchorOrigin={{\r\n          vertical: 'bottom',\r\n          horizontal: 'left',\r\n        }}\r\n        open={ this.state.errors && this.state.errors.length > 0 }\r\n        autoHideDuration={ 6000 }\r\n        ContentProps={{\r\n          'aria-describedby': 'message-id',\r\n        }}\r\n        message={ this.state.errors ? this.state.errors.join(',\\n') : '' }\r\n        action={[\r\n          <IconButton\r\n            key=\"close\"\r\n            aria-label=\"close\"\r\n            onClick={ () => this.removeError() }\r\n            color=\"inherit\">\r\n            <CloseIcon />\r\n          </IconButton>,\r\n        ]}\r\n      />\r\n    );\r\n\r\n  }\r\n\r\n  /**\r\n   * Clears errors when snackbar is closed.\r\n   * NOTE: This method updates component state.\r\n   */\r\n  removeError = () => {\r\n\r\n    this.setState({\r\n      errors: undefined\r\n    });\r\n\r\n  }\r\n\r\n}\r\n\r\nexport default App;","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}